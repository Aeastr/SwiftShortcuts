//
//  FetchShortcut.swift
//  SwiftShortcuts
//
//  Fetches shortcut metadata from iCloud and outputs it as JSON.
//
//  Usage:
//    swift run sstools fetch abc123
//    swift run sstools fetch abc123 def456 ghi789
//    swift run sstools fetch --file links.txt -o shortcuts.json
//

import ArgumentParser
import Foundation

struct FetchShortcut: AsyncParsableCommand {
    static let configuration = CommandConfiguration(
        commandName: "fetch",
        abstract: "Fetch shortcut data from iCloud and output as JSON"
    )

    @Argument(help: "Shortcut URLs or IDs")
    var shortcuts: [String] = []

    @Option(name: .shortAndLong, help: "File containing URLs/IDs (one per line)")
    var file: String?

    @Flag(name: .shortAndLong, help: "Pretty print the JSON output")
    var pretty: Bool = false

    @Flag(name: .shortAndLong, help: "Include workflow actions in output")
    var actions: Bool = false

    @Option(name: .shortAndLong, help: "Output file path (prints to stdout if not specified)")
    var output: String?

    @Flag(name: .long, help: "Output as Swift code instead of JSON")
    var swift: Bool = false

    @Option(name: .long, help: "Array name for Swift output (default: shortcuts)")
    var arrayName: String = "shortcuts"

    func validate() throws {
        if shortcuts.isEmpty && file == nil {
            throw ValidationError("Provide at least one shortcut URL/ID or use --file")
        }
    }

    func run() async throws {
        var allInputs = shortcuts

        // Read from file if provided
        if let filePath = file {
            let fileURL = URL(fileURLWithPath: filePath)
            let contents = try String(contentsOf: fileURL, encoding: .utf8)
            let lines = contents
                .components(separatedBy: .newlines)
                .map { $0.trimmingCharacters(in: .whitespaces) }
                .filter { !$0.isEmpty && !$0.hasPrefix("#") }
            allInputs.append(contentsOf: lines)
        }

        fputs("Fetching \(allInputs.count) shortcut(s)...\n", stderr)

        var results: [ShortcutOutput] = []
        var failed: [String] = []

        for (index, input) in allInputs.enumerated() {
            let shortcutID = extractShortcutID(from: input)
            fputs("[\(index + 1)/\(allInputs.count)] \(shortcutID)...", stderr)

            do {
                let shortcut = try await fetchShortcut(id: shortcutID)
                results.append(shortcut)
                fputs(" ✓\n", stderr)
            } catch {
                failed.append(shortcutID)
                fputs(" ✗ \(error.localizedDescription)\n", stderr)
            }
        }

        if !failed.isEmpty {
            fputs("\nFailed: \(failed.joined(separator: ", "))\n", stderr)
        }

        fputs("\nFetched \(results.count)/\(allInputs.count) shortcuts\n", stderr)

        // Generate output
        let outputString: String
        if swift {
            outputString = generateSwiftCode(results)
        } else {
            let encoder = JSONEncoder()
            encoder.keyEncodingStrategy = .convertToSnakeCase
            if pretty || output != nil {
                encoder.outputFormatting = [.prettyPrinted, .sortedKeys]
            }

            let jsonData: Data
            if results.count == 1 {
                jsonData = try encoder.encode(results[0])
            } else {
                jsonData = try encoder.encode(results)
            }
            outputString = String(data: jsonData, encoding: .utf8) ?? ""
        }

        if let outputPath = output {
            let fileURL = URL(fileURLWithPath: outputPath)
            try outputString.write(to: fileURL, atomically: true, encoding: .utf8)
            fputs("Saved to \(outputPath)\n", stderr)
        } else {
            print(outputString)
        }
    }

    // MARK: - Swift Code Generation

    private func generateSwiftCode(_ shortcuts: [ShortcutOutput]) -> String {
        var code = """
        //
        //  Shortcuts.swift
        //
        //  Generated by sstools on \(ISO8601DateFormatter().string(from: Date()))
        //

        import SwiftShortcuts

        let \(arrayName): [ShortcutData] = [

        """

        for shortcut in shortcuts {
            code += """
                ShortcutData(
                    id: "\(shortcut.id)",
                    name: "\(escaped(shortcut.name))",
                    iconColor: \(shortcut.iconColor),
                    iconGlyph: \(shortcut.iconGlyph),
                    iconURL: \(optionalString(shortcut.iconURL)),
                    shortcutURL: \(optionalString(shortcut.shortcutURL)),
                    iCloudLink: "\(shortcut.iCloudLink)"
                ),

            """
        }

        code += """
        ]

        """

        return code
    }

    private func escaped(_ string: String) -> String {
        string
            .replacingOccurrences(of: "\\", with: "\\\\")
            .replacingOccurrences(of: "\"", with: "\\\"")
            .replacingOccurrences(of: "\n", with: "\\n")
    }

    private func optionalString(_ value: String?) -> String {
        if let value {
            return "\"\(escaped(value))\""
        }
        return "nil"
    }

    // MARK: - Fetching

    private func fetchShortcut(id shortcutID: String) async throws -> ShortcutOutput {
        let apiURL = "https://www.icloud.com/shortcuts/api/records/\(shortcutID)"

        guard let url = URL(string: apiURL) else {
            throw ValidationError("Invalid shortcut ID")
        }

        let (data, response) = try await URLSession.shared.data(from: url)

        guard let httpResponse = response as? HTTPURLResponse else {
            throw ValidationError("Invalid response")
        }

        guard httpResponse.statusCode == 200 else {
            throw ValidationError("Not found (status \(httpResponse.statusCode))")
        }

        let cloudKitResponse = try JSONDecoder().decode(CloudKitResponse.self, from: data)

        var shortcutOutput = ShortcutOutput(
            id: cloudKitResponse.recordName,
            name: cloudKitResponse.fields.name.value,
            iconColor: cloudKitResponse.fields.icon_color.value,
            iconGlyph: cloudKitResponse.fields.icon_glyph.value,
            iconURL: cloudKitResponse.fields.icon?.value.downloadURL,
            shortcutURL: constructAssetURL(cloudKitResponse.fields.shortcut?.value.downloadURL),
            iCloudLink: "https://www.icloud.com/shortcuts/\(shortcutID)"
        )

        if actions, let shortcutURL = shortcutOutput.shortcutURL {
            shortcutOutput.actions = try await fetchWorkflowActions(from: shortcutURL)
        }

        return shortcutOutput
    }

    // MARK: - Helpers

    private func extractShortcutID(from input: String) -> String {
        if input.contains("icloud.com") || input.contains("/") {
            guard let url = URL(string: input) else { return input }
            let path = url.path

            if path.contains("/api/records/") {
                return path.components(separatedBy: "/api/records/").last ?? input
            }

            return url.lastPathComponent
        }
        return input
    }

    private func constructAssetURL(_ templateURL: String?) -> String? {
        guard let templateURL else { return nil }
        return templateURL.replacingOccurrences(of: "${f}", with: "shortcut.plist")
    }

    private func fetchWorkflowActions(from urlString: String) async throws -> [ActionOutput] {
        guard let url = URL(string: urlString) else {
            throw ValidationError("Invalid shortcut URL")
        }

        let (data, _) = try await URLSession.shared.data(from: url)

        guard let plist = try PropertyListSerialization.propertyList(
            from: data,
            options: [],
            format: nil
        ) as? [String: Any] else {
            throw ValidationError("Could not parse shortcut plist")
        }

        guard let actions = plist["WFWorkflowActions"] as? [[String: Any]] else {
            return []
        }

        return actions.compactMap { dict -> ActionOutput? in
            guard let identifier = dict["WFWorkflowActionIdentifier"] as? String else {
                return nil
            }

            let params = dict["WFWorkflowActionParameters"] as? [String: Any]
            var controlFlowMode: Int?
            if let mode = params?["WFControlFlowMode"] as? Int {
                controlFlowMode = mode
            }

            return ActionOutput(
                identifier: identifier,
                controlFlowMode: controlFlowMode
            )
        }
    }
}

// MARK: - CloudKit Response

private struct CloudKitResponse: Codable {
    let recordName: String
    let fields: Fields

    struct Fields: Codable {
        let name: ValueWrapper<String>
        let icon_color: ValueWrapper<Int64>
        let icon_glyph: ValueWrapper<Int64>
        let icon: AssetField?
        let shortcut: AssetField?

        struct ValueWrapper<T: Codable>: Codable {
            let value: T
        }

        struct AssetField: Codable {
            let value: AssetValue

            struct AssetValue: Codable {
                let downloadURL: String
            }
        }
    }
}

// MARK: - Output Structures

private struct ShortcutOutput: Codable {
    let id: String
    let name: String
    let iconColor: Int64
    let iconGlyph: Int64
    let iconURL: String?
    let shortcutURL: String?
    let iCloudLink: String
    var actions: [ActionOutput]?
}

private struct ActionOutput: Codable {
    let identifier: String
    let controlFlowMode: Int?
}
